- 청사진을 그려보자 1.1
    - 데이터를 구성해보자
        
        공유 메모리 내부 구조체
        
        ```c
        //shared memeory data
        typedef struct s_shm {
        	int height;
        	int width;
        	int player_nbs;
        	int board[h][w];
        } t_shm;
        ```
        
        ```c
        //msgq data
        typedef struct s_myMsgbuf{
        	long mytyep; //1 전체채널, 2 팀채널
        	int team_no;
        	int x;
        	int y;
        	int kind; //0 게임 시작, 1 (x, y) 죽음, 2 게임끝
        }t_myMsgbuf;
        ```
        
        ```c
        //user data
        typedef struct s_playerData{
        	int team_no;
        	int x;
        	int y;
        	int t_key;
        	int team_mb_cnt; //if num 1 is failer game
        	int qid; //msg queue id
        	int sid; //semaphore id
        	int mid; //shm id
        }t_playerData;
        ```
        
        ```c
        //const value
        #define WIDTH 100
        #define HEITHT 100
        #define MAXTEAM 9
        #defind MAXTEAMNB 5
        #defind PATHNAME "./temp"
        #defind PROJID 'A'
        ```
        
    - 프로그램의 동작방법을 글로 한번 적어보자
        
        플레이어 한 명 기준 ‘한 턴’에 일어나는 일
        
        아래의 경우에서 나는 세마포어를 무조건 잡아야지 진행을 시킬 건지 아니면 스케줄러에따라서 불공평하지만 이번 턴을 스킵할 수도 있는건지 생각을 해봐야 한다.
        
        1. 프로그램시작시 ./lemipc <team_id>
            1. player가 first 라며 ipc들을 생성한다. (msgq, sem, shm)
                1. ipc들을 초기화 하며, t_shm 공용 구조체를 생성하고 초기화한다.
            2. first 가 아니라면 팀인원이 맞는지 확인하고 ipc 에 attach 한다.
            3. 프로그램이 자동으로 부여하는 자리를 얻어서, 좌표를 결정하고, 공유메모리에 내가 있는 자리에 팀번호를 입력한다.
            4. 첫번째 플레이어가 사람이 다 구해지면 메세지버퍼에 게임 시작을 알린다.
                1. 플레이가 되며(알고리즘이 작동하며 ) 화면에 출력이된다.
        2. 메인 루프
            1. 메세지큐를 확인한다.
            2. 세마포어를 락한다.
                1. 현재 보드 상태를 읽는다. 
                2. 내 주변 (x -1, x + 1) (y - 1, y  +1)을 보고 내 주위에 적이 있는지 확인한다.
                    1. 적이 있다면 shm 에서 player_nbs -=1 과 보드를 초기화 하고 죽음 방송을 위한 플래그를 올려놓는다.
                        1. 모든 플레이어는 죽음 방송을 듣고 총 플레이어의 cnt 를 - 1 한다.
                3. 적이 없다면 알고리즘이 미리 가라고 정한방향으로 한칸 이동후 이전 자리를 초기화한다.
                    1. 만약 알고리즘이 추적값이 없거나 목표가 사라졌다면 직접 가까운 적을 확인하고 팀원들에게 전파를 한다는 플래그를올리고 좌표를 저장후, 이후 이동한다.
            3. 세마포어 락을 해제한다.
            4. 메세지 큐플래그가 true라면 저장된 값을 메세지큐에 올린후 다시 루프를 돈다.
        3. 프로세스 종료시
            1. 죽음 방송 플래그가 on이라면 혹시나 내가 마지막 사람인걸 확인한다
                1. 마지막사람이 아니라면 자기자신의 내용만 정리후 종료
            2. 마지막 사람이라면 ipc 들을 모두 정리후 삭제한다. 문제에서 프로세스를 끄라고는안함
        - 아직 고려해야할점
            - health check 를 넣어서 안전성을 확보할 것 인가? 안전성을 확보한다면 health check의 응답률과 현재 프로세스의 멤버의 수가 맞지 않는다면 그건 error로 보고 프로세스를 종료해야하는가? 아니면 우승자가 남을때까지 계속해서 게임을 해야하는가?
            - 위경우 3명이 남은경우 누군가 게임을 강제종료한다면, shm 은 초기화 되지 않고 이전 값을 계속해서 가지고 있는데 이경우 게임을 끝낼 수 있는 방법은 심판자를 넣는 방법이 있다. 하지만 심판자를넣는순간 게임의 로직이 아예변경(문제에서 처음 플레이어가 ipc를 성한다고 라고 했는데 만약 심판자가 들어가게 되면 그건 언제 생성이되어야 하는가의 문제)이 되기때문에 health check를 넣는 방법이 간단한 방법이아닐까?
    - 공유메모리 동작 방식
        
        <aside>
        💡
        
        질문 : shmat 는 공유메모리의 첫주소를반환 해 ? 그리고 저건 mmap 같이 16의 제곱수를반환해 ?
        
        좋은 질문이다. 직관적으로 정리하면:
        
        1. shmat가 무엇을 반환하느냐
        - `shmat`는 “그 공유 메모리가 이 프로세스 주소 공간에서 시작하는 가상 주소”를 반환한다.
        - 즉, `void *p = shmat(...);` 했을 때 `p`는 그 세그먼트의 첫 바이트(베이스 주소)를 가리키는 포인터라고 생각하면 된다.
        - 이후 `((char *)p)[0]`, `((char *)p)[1]`, 혹은 `struct mydata *d = p; d->field` 이런 식으로, 그 주소를 기준으로 네가 정의한 레이아웃대로 접근하면 된다.
        1. mmap처럼 “16의 제곱수(페이지 정렬)”를 보장하느냐
        - `shmat`가 실제 내부에서는 페이지 단위로 매핑되기 때문에, 커널 입장에서는 페이지 경계에 맞춰 붙인다.
        - 하지만 사용자 입장에서 “반환 주소가 반드시 0x1000 배수(4K), 0x10000 배수 이런 식의 2의 거듭제곱 정렬이 온다”는 보장은 표준에서 명시적으로 해주지 않는다.
        - 다만 일반적인 리눅스 구현에서는 `shmat(shmid, NULL, 0)`처럼 주소를 직접 지정하지 않고 호출하면, `mmap`처럼 페이지 정렬된 적당한 가상 주소를 골라준다. 그래서 보통 나오는 주소는 페이지 크기(4K 등)의 배수인 경우가 대부분이다.
        - 정렬이 진짜로 중요한 경우(예: 특정 SIMD용 정렬 요구)에는:
            - `shmaddr`를 직접 지정해서 `shmat`에 넘기되, 페이지 크기와 플래그 제약을 맞춰 쓰거나
            - 혹은 그냥 공유 메모리 위에서 내부적으로 “내가 쓸 영역은 이 베이스에서 N 바이트 패딩 후” 식으로 수동 정렬을 맞춰서 쓰는 패턴이 더 안전하다.
        
        정리하면:
        
        - 반환값은 그 공유 메모리 세그먼트의 시작 가상 주소다.
        - 내부적으로는 페이지 단위로 붙지만, “반드시 2의 거듭제곱 정렬 주소를 반환한다”는 식의 강한 보장은 사양에 없고, 구현에 따라 그렇게 동작하는 게 일반적이라고 보는 편이 맞다.
        1. https://12bme.tistory.com/227
        2. https://blog.naver.com/PostView.naver?blogId=cache798&logNo=130005278988
        3. https://young-cow.tistory.com/12
        4. https://jihooyim1.gitbooks.io/unixbasic/content/contents/10.html
        5. https://josushell.tistory.com/83
        6. https://sosal.kr/344
        7. https://taesun1114.tistory.com/entry/%EA%B3%B5%EC%9C%A0%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%95%A8%EC%88%98-shmget-shmat-shmdt
        8. https://www.it-note.kr/110
        9. https://velog.io/@ckh0824/%EC%8B%9C%EC%8A%A4%ED%85%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D12
        10. https://nlnf.tistory.com/entry/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%99%80-%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B45
        </aside>